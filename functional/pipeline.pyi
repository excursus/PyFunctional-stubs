from functional import transformations as transformations
from functional.execution import ExecutionEngine as ExecutionEngine, ExecutionStrategies as ExecutionStrategies
from functional.io import WRITE_MODE as WRITE_MODE, universal_write_open as universal_write_open
from functional.lineage import Lineage as Lineage
from functional.util import identity as identity, is_iterable as is_iterable, is_namedtuple as is_namedtuple, is_primitive as is_primitive, is_tabulatable as is_tabulatable
from typing import Any, Optional, Iterable, Generic, TypeVar, Callable


## From: https://stackoverflow.com/questions/47965083/comparable-types-with-mypy
from typing_extensions import Protocol
from abc import abstractmethod
C = TypeVar("C", bound="Comparable")
class Comparable(Protocol):
    @abstractmethod
    def __eq__(self, other: Any) -> bool: # type: ignore
        pass
    @abstractmethod
    def __lt__(self: C, other: C) -> bool:
        pass
    def __gt__(self: C, other: C) -> bool:
        return (not self < other) and self != other
    def __le__(self: C, other: C) -> bool:
        return self < other or self == other
    def __ge__(self: C, other: C) -> bool:
        return (not self < other)


T = TypeVar('T')
U = TypeVar('U')
class Sequence(Generic[T]):
    engine: Any = ...
    def __init__(self, sequence: Iterable[T], transform: Optional[Any] = ..., engine: Optional[Any] = ..., max_repr_items: Optional[Any] = ...) -> None: ...
    def __iter__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    def __bool__(self): ...
    def __nonzero__(self): ...
    def __getitem__(self, item: Any): ...
    def __reversed__(self): ...
    def __contains__(self, item: Any): ...
    def __add__(self, other: Any): ...
    @property
    def sequence(self): ...
    def cache(self, delete_lineage: bool = ...): ...
    def head(self): ...
    def first(self): ...
    def head_option(self): ...
    def last(self): ...
    def last_option(self): ...
    def init(self): ...
    def tail(self): ...
    def inits(self): ...
    def tails(self): ...
    def cartesian(self, *iterables: Any, **kwargs: Any): ...
    def drop(self, n: Any): ...
    def drop_right(self, n: Any): ...
    def drop_while(self, func: Any): ...
    def take(self, n: Any): ...
    def take_while(self, func: Any): ...
    def union(self, other: Any): ...
    def intersection(self, other: Any): ...
    def difference(self, other: Any): ...
    def symmetric_difference(self, other: Any): ...
    def map(self, func: Any): ...
    def select(self, func: Any): ...
    def starmap(self, func: Any): ...
    def smap(self, func: Any): ...
    def for_each(self, func: Any) -> None: ...
    def filter(self, func: Any): ...
    def filter_not(self, func: Any): ...
    def where(self, func: Any): ...
    def count(self, func: Any): ...
    def len(self): ...
    def size(self): ...
    def empty(self): ...
    def non_empty(self): ...
    def any(self): ...
    def all(self): ...
    def exists(self, func: Any): ...
    def for_all(self, func: Any): ...
    def max(self): ...
    def min(self): ...
    def max_by(self, func: Any): ...
    def min_by(self, func: Any): ...
    def find(self, func: Any): ...
    def flatten(self): ...
    def flat_map(self, func: Callable[[T], Iterable[U]]) -> Sequence[U]: ...
    def group_by(self, func: Any): ...
    def group_by_key(self): ...
    def reduce_by_key(self, func: Any): ...
    def count_by_key(self): ...
    def count_by_value(self): ...
    def reduce(self, func: Any, *initial: Any): ...
    def accumulate(self, func: Any = ...): ...
    def make_string(self, separator: Any): ...
    def product(self, projection: Optional[Any] = ...): ...
    def sum(self, projection: Optional[Any] = ...): ...
    def average(self, projection: Optional[Any] = ...): ...
    def aggregate(self, *args: Any): ...
    def fold_left(self, zero_value: Any, func: Any): ...
    def fold_right(self, zero_value: Any, func: Any): ...
    def zip(self, sequence: Any): ...
    def zip_with_index(self, start: int = ...): ...
    def enumerate(self, start: int = ...): ...
    def inner_join(self, other: Any): ...
    def join(self, other: Any, join_type: str = ...): ...
    def left_join(self, other: Any): ...
    def right_join(self, other: Any): ...
    def outer_join(self, other: Any): ...
    def partition(self, func: Any): ...
    def grouped(self, size: Any): ...
    def sliding(self, size: Any, step: int = ...): ...
    def sorted(self, key: Optional[Callable[[T], Comparable]] = ..., reverse: bool = ...) -> Sequence[T]: ...
    def order_by(self, func: Any): ...
    def reverse(self): ...
    def distinct(self): ...
    def distinct_by(self, func: Any): ...
    def slice(self, start: Any, until: Any): ...
    def to_list(self, n: Optional[Any] = ...): ...
    def list(self, n: Optional[Any] = ...): ...
    def to_set(self): ...
    def set(self): ...
    def to_dict(self, default: Optional[Any] = ...): ...
    def dict(self, default: Optional[Any] = ...): ...
    def to_file(self, path: Any, delimiter: Optional[Any] = ..., mode: str = ..., buffering: int = ..., encoding: Optional[Any] = ..., errors: Optional[Any] = ..., newline: Optional[Any] = ..., compresslevel: int = ..., format: Optional[Any] = ..., check: int = ..., preset: Optional[Any] = ..., filters: Optional[Any] = ..., compression: Optional[Any] = ...) -> None: ...
    def to_jsonl(self, path: Any, mode: str = ..., compression: Optional[Any] = ...) -> None: ...
    def to_json(self, path: Any, root_array: bool = ..., mode: Any = ..., compression: Optional[Any] = ...) -> None: ...
    def to_csv(self, path: Any, mode: Any = ..., dialect: str = ..., compression: Optional[Any] = ..., newline: str = ..., **fmtparams: Any) -> None: ...
    def to_sqlite3(self, conn: Any, target: Any, *args: Any, **kwargs: Any) -> None: ...
    def to_pandas(self, columns: Optional[Any] = ...): ...
    def show(self, n: int = ..., headers: Any = ..., tablefmt: str = ..., floatfmt: str = ..., numalign: str = ..., stralign: str = ..., missingval: str = ...) -> None: ...
    def tabulate(self, n: Optional[Any] = ..., headers: Any = ..., tablefmt: str = ..., floatfmt: str = ..., numalign: str = ..., stralign: str = ..., missingval: str = ...): ...

def extend(func: Optional[Any] = ..., aslist: bool = ..., final: bool = ..., name: Optional[Any] = ..., parallel: bool = ...): ...
